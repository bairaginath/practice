Spring-boot
============
@SpringBootApplication

Spring MVC
@Controller
public class SimpleController {
    @Value("${spring.application.name}")
    String appName;
 
    @GetMapping("/")
    public String homePage(Model model) {
        model.addAttribute("appName", appName);
        return "home";
    }
}

for JPA persistance
====================
@EnableJpaRepositories("org.baeldung.persistence.repo") 
@EntityScan("org.baeldung.persistence.model")
@SpringBootApplication
public class Application {
   ...
}

Error Handling
===============
@ControllerAdvice
public class RestExceptionHandler extends ResponseEntityExceptionHandler {
 
    @ExceptionHandler({ BookNotFoundException.class })
    protected ResponseEntity<Object> handleNotFound(
      Exception ex, WebRequest request) {
        return handleExceptionInternal(ex, "Book not found", 
          new HttpHeaders(), HttpStatus.NOT_FOUND, request);
    }
 
    @ExceptionHandler({ BookIdMismatchException.class, 
      ConstraintViolationException.class, 
      DataIntegrityViolationException.class })
    public ResponseEntity<Object> handleBadRequest(
      Exception ex, WebRequest request) {
        return handleExceptionInternal(ex, ex.getLocalizedMessage(), 
          new HttpHeaders(), HttpStatus.BAD_REQUEST, request);
    }
}

Spring Boot Annotations
=======================
@EnableAutoConfiguration : by default Auto configuration is enable.
if you want to bean creation by own or some condition , exclude that bean as below
@EnableAutoConfiguration(exclude={MySQLAutoconfiguration.class})

Conditions 
==========
class condition : 
-----------------
@Configuration
@ConditionalOnClass(DataSource.class)
public class MySQLAutoconfiguration {}

bean condition :
-----------------
@Bean
@ConditionalOnBean(name = "dataSource")
@ConditionalOnMissingBean
public LocalContainerEntityManagerFactoryBean entityManagerFactory() {}

Properties conditions :
-------------------------
@Bean
@ConditionalOnProperty(
  name = "usemysql", 
  havingValue = "local")
@ConditionalOnMissingBean
public DataSource dataSource() {}

Resource Condition :
---------------------
@ConditionalOnResource(  resources = "classpath:mysql.properties")

Custom Conditions :
===================
static class HibernateCondition extends SpringBootCondition { 
    @Override
    public ConditionOutcome getMatchOutcome(ConditionContext context, 
      AnnotatedTypeMetadata metadata) { } 
	}
	
used as below
@Conditional(HibernateCondition.class)
Properties additionalProperties() {}

Application Conditions : We can also specify that the configuration can be loaded only inside/outside a web context, by adding the @ConditionalOnWebApplication or @ConditionalOnNotWebApplication annotation.

The Web Starter
===============
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

This dependency will works for developing the REST service; we can use libraries like Spring MVC, Tomcat and Jackson – a lot of dependencies for a single application.

The Test Starter
================
Spring Test, JUnit, Hamcrest, and Mockito.
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
example 
-------
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@WebAppConfiguration
public class SpringBootApplicationIntegrationTest {
    @Autowired
    private WebApplicationContext webApplicationContext;
    private MockMvc mockMvc;
 
    @Before
    public void setupMockMvc() {
        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
    }
 
    @Test
    public void givenRequestHasBeenMade_whenMeetsAllOfGivenConditions_thenCorrect()
      throws Exception { } 
}

Priority Order of Configurations
=================================
    Java Config
    Command Line Arguments
    Java System Properties
    OS Environment Variables
    application.properties in Current Directory
    application.properties in the classpath (src/main/resources or the packaged jar file)

@ConfigurationProperties in Spring Boot
=======================================
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.1.3.RELEASE</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>

@Configuration
@PropertySource("classpath:configprops.properties")
@ConfigurationProperties(prefix = "mail")
public class ConfigProperties {
     
    private String hostName;
    private int port;
    private String from;
 
    // standard getters and setters
}

@SpringBootApplication
@EnableConfigurationProperties(ConfigProperties.class)
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}

Developing with Spring Boot brings several advantages:

    simpler dependency management
    default auto-configuration
    embedded web server
    application metrics and health checks
    advanced externalized configuration


Filter
======
Defining Filters and the Invocation Order
@Component
@Order(1)
public class TransactionFilter implements Filter {
 
    @Override
    public void doFilter(
      ServletRequest request, 
      ServletResponse response, 
      FilterChain chain) throws IOException, ServletException { }
}

@Component
@Order(2)
public class RequestResponseLoggingFilter implements Filter {
 
    @Override
    public void doFilter(
      ServletRequest request, 
      ServletResponse response, 
      FilterChain chain) throws IOException, ServletException { }
}

output :
TransactionFilter - request
RequestResponseLoggingFilter - request
RequestResponseLoggingFilter -respoonse
TransactionFilter - response 

SpringBootServletInitializer
==============================
This class binds Servlet, Filter and ServletContextInitializer beans from the application context to the server.

@SpringBootApplication
public class WarInitializerApplication extends SpringBootServletInitializer {
 
    @Override
    protected SpringApplicationBuilder configure(
      SpringApplicationBuilder builder) {
        return builder.sources(WarInitializerApplication.class);
    }
 
    public static void main(String[] args) {
        SpringApplication sa = new SpringApplication(
          WarInitializerApplication.class);
        sa.run(args);
    }     
}

Now, if we package our application as a WAR, we’ll be able to deploy it on any web container in a traditional way,

Spring Boot Exit Codes
======================
@SpringBootApplication
public class DemoApplication implements ExitCodeGenerator {
 
    public static void main(String[] args) {
        System.exit(SpringApplication
          .exit(SpringApplication.run(DemoApplication.class, args)));
    }
  
    @Override
    public int getExitCode() {
        return 42;
    }
}


Shutdown a Spring Boot Application
curl -X POST localhost:port/actuator/shutdown

Spring Boot Actuator
=====================
Monitoring our app, gathering metrics, understanding traffic or the state of our database becomes trivial with this dependency.
The main benefit of this library is that we can get production grade tools without having to actually implement these features ourselves
Actuator is mainly used to expose operational information about the running application – health, metrics, info, dump, env, etc. It uses HTTP endpoints or JMX beans to enable us to interact with it.
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
Spring Boot 1.x Actuator
-------------------------
Actuator requires Spring MVC to expose its endpoints through HTTP.
In 1.x Actuator follows a R/W model(we can retrieve metrics or the health of our application. Alternatively, we could gracefully terminate our app or change our logging configuration)

    /health – Shows application health information (a simple ‘status' when accessed over an unauthenticated connection or full message details when authenticated); it's not sensitive by default
    /info – Displays arbitrary application info; not sensitive by default
    /metrics – Shows ‘metrics' information for the current application; it's also sensitive by default(information about OS, JVM as well as application level metrics)
    /trace – Displays trace information (by default the last few HTTP requests)

Three properties are available:
    id – by which this endpoint will be accessed over HTTP
    enabled – if true then it can be accessed otherwise not
    sensitive – if true then need the authorization to show crucial information over HTTP
ex: endpoints.beans.id=springbeans
endpoints.beans.sensitive=false
endpoints.beans.enabled=true

We could also implement our own custom health indicator 
We can also customize the data shown by the /info endpoint 
we can create new endpoint by implements Endpoint<List<T>>
 If the application is using Spring Security – we can secure these endpoints by defining the default security properties – username, password, and role – in the application.properties file

Spring Boot 2.x Actuator
------------------------
supports  CRUD model and extensible without relying on MVC
only two available by default are /health and /info.
Actuator now shares the security config with the regular App security rules. Hence, the security model is dramatically simplified. (Actuator now shares the security config with the regular App security rules. Hence, the security model is dramatically simplified. )

    /auditevents – lists security audit-related events such as user login/logout. Also, we can filter by principal or type among others fields
    /beans – returns all available beans in our BeanFactory. Unlike /auditevents, it doesn't support filtering
    /conditions – formerly known as /autoconfig, builds a report of conditions around auto-configuration
    /configprops – allows us to fetch all @ConfigurationProperties beans
    /env – returns the current environment properties. Additionally, we can retrieve single properties
    /flyway – provides details about our Flyway database migrations
    /health – summarises the health status of our application
    /heapdump – builds and returns a heap dump from the JVM used by our application
    /info – returns general information. It might be custom data, build information or details about the latest commit
    /liquibase – behaves like /flyway but for Liquibase
    /logfile – returns ordinary application logs
    /loggers – enables us to query and modify the logging level of our application
    /metrics – details metrics of our application. This might include generic metrics as well as custom ones
    /prometheus – returns metrics like the previous one, but formatted to work with a Prometheus server
    /scheduledtasks – provides details about every scheduled task within our application
    /sessions – lists HTTP sessions given we are using Spring Session
    /shutdown – performs a graceful shutdown of the application
    /threaddump – dumps the thread information of the underlying JVM

Customizing the /info,/health,/metrics Endpoint
we can create custom new endpoint .ex:
@Endpoint(id = "endpointname",enableByDefault = false)
class NewEndpoint {
@ReadOperation – it'll map to HTTP GET
@WriteOperation – it'll map to HTTP POST
@DeleteOperation – it'll map to HTTP DELETE
}


	  