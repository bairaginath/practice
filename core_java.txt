String Literal vs String Object
===============================
When we create a String object using the new() operator, it always creates a new object in heap memory. On the other hand, if we create an object using String literal syntax e.g. “Baeldung”, it may return an existing object from the String pool, if it already exists. Otherwise, it will create a new String object and put in the string pool for future re-use.

At a high level, both are the String objects, but the main difference comes from the point that new() operator always creates a new String object. Also, when we create a String using literal – it is interned.

String constantString = "interned Baeldung";
String newString = new String("interned Baeldung");
 
assertThat(constantString).isNotSameAs(newString);
 
String internedString = newString.intern();
 
assertThat(constantString)
  .isSameAs(internedString);

Before Java 7, the JVM placed the Java String Pool in the PermGen space, which has a fixed size — it can't be expanded at runtime and is not eligible for garbage collection.

The risk of interning Strings in the PermGen (instead of the Heap) is that we can get an OutOfMemory error from the JVM if we intern too many Strings.

From Java 7 onwards, the Java String Pool is stored in the Heap space, which is garbage collected by the JVM. The advantage of this approach is the reduced risk of OutOfMemory error because unreferenced Strings will be removed from the pool, thereby releasing memory.

When we create a String variable and assign a value to it, the JVM searches the pool for a String of equal value.
If found, the Java compiler will simply return a reference to its memory address, without allocating additional memory.
In this way,JVM can optimize the amount of memory allocated for them by storing only one copy of each literal String in the pool. This process is called interning.

features that immutability provides, such as caching, security, easy reuse without replication, etc.
An immutable object is an object whose internal state remains constant after it has been entirely created. 

Why String is immutable 
------------------------
The key benefits of keeping String class as immutable are caching, security, synchronization, and performance.
string pool (caching)
------
Java String Pool is the special memory region where Strings are stored by the JVM. Since Strings are immutable in Java, the JVM optimizes the amount of memory allocated for them by storing only one copy of each literal String in the pool. This process is called interning:
String s1 = "Hello World";
String s2 = "Hello World";
assertThat(s1 == s2).isTrue();
Because of the presence of the String pool in the preceding example, two different variables are pointing to same String object from the pool, thus saving crucial memory resource.
Security
-----
The String is widely used in Java applications to store sensitive pieces of information like usernames, passwords, connection URLs, network connections, etc. It's also used extensively by JVM class loaders while loading classes.
void criticalMethod(String userName) {
    // perform security checks
    if (!isAlphaNumeric(userName)) {
        throw new SecurityException(); 
    }
     
    // do some secondary tasks
    initializeDatabase();
     
    // critical task
    connection.executeUpdate("UPDATE Customers SET Status = 'Active' " +
      " WHERE UserName = '" + userName + "'");
}
In the above code snippet, let's say that we received a String object from an untrustworthy source. We're doing all necessary security checks initially to check if the String is only alphanumeric, followed by some more operations.

Remember that our unreliable source caller method still has reference to this userName object.

If Strings were mutable, then by the time we execute the update, we can't be sure that the String we received, even after performing security checks, would be safe. The untrustworthy caller method still has the reference and can change the String between integrity checks. Thus making our query prone to SQL injections in this case. So mutable Strings could lead to degradation of security over time.

It could also happen that the String userName is visible to another thread, which could then change its value after the integrity check.

In general, immutability comes to our rescue in this case because it's easier to operate with sensitive code when values don't change because there are fewer interleavings of operations that might affect the result.
Synchronization
-----
Being immutable automatically makes the String thread safe since they won't be changed when accessed from multiple threads.

Hence immutable objects, in general, can be shared across multiple threads running simultaneously. They're also thread-safe because if a thread changes the value, then instead of modifying the same, a new String would be created in the String pool. Hence, Strings are safe for multi-threading.
 Hashcode Caching
 ----------------
Since String objects are abundantly used as a data structure, they are also widely used in hash implementations like HashMap, HashTable, HashSet, etc. When operating upon these hash implementations, hashCode() method is called quite frequently for bucketing.

The immutability guarantees Strings that their value won’t change. So the hashCode() method is overridden in String class to facilitate caching, such that the hash is calculated and cached during the first hashCode() call and the same value is returned ever since.

This, in turn, improves the performance of collections that uses hash implementations when operated with String objects.

On the other hand, mutable Strings would produce two different hashcodes at the time of insertion and retrieval if contents of String was modified after the operation, potentially losing the value object in the Map.

Performance
-------
As we saw previously, String pool exists because Strings are immutable. In turn, it enhances the performance by saving heap memory and faster access of hash implementations when operated with Strings.

Since String is the most widely used data structure, improving the performance of String have a considerable effect on improving the performance of the whole application in general.


Comparator.comparing method
===========================
1)public static <T, U extends Comparable<? super U>> Comparator<T> comparing(
            Function<? super T, ? extends U> keyExtractor)
    {
        Objects.requireNonNull(keyExtractor);
        return (Comparator<T> & Serializable)
            (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
    }
Comparator<Employee> employeeNameComparator
      = Comparator.comparing(Employee::getName);

Arrays.sort(employees, employeeNameComparator);



2)public static <T, U> Comparator<T> comparing(
            Function<? super T, ? extends U> keyExtractor,
            Comparator<? super U> keyComparator)
    {
        Objects.requireNonNull(keyExtractor);
        Objects.requireNonNull(keyComparator);
        return (Comparator<T> & Serializable)
            (c1, c2) -> keyComparator.compare(keyExtractor.apply(c1),
                                              keyExtractor.apply(c2));
    }

Comparator<Employee> employeeNameComparator
      = Comparator.comparing(
        Employee::getName, (s1, s2) -> {
            return s2.compareTo(s1);
        });
     
    Arrays.sort(employees, employeeNameComparator);

3)natural order
public static <T extends Comparable<? super T>> Comparator<T> naturalOrder() {
        return (Comparator<T>) Comparators.NaturalOrderComparator.INSTANCE;
    }
Comparator<Employee> employeeNameComparator 
      = Comparator.<Employee> naturalOrder();
     
    Arrays.sort(employees, employeeNameComparator);

4) reverse order 
public static <T extends Comparable<? super T>> Comparator<T> reverseOrder() {
        return Collections.reverseOrder();
    }

5) Null last
public static <T> Comparator<T> nullsLast(Comparator<? super T> comparator) {
        return new Comparators.NullComparator<>(false, comparator); //false means nullsLast ,otherwise nullsFirst
    }

Comparator<Employee> employeeNameComparator
      = Comparator.comparing(Employee::getName);
    Comparator<Employee> employeeNameComparator_nullLast
      = Comparator.nullsLast(employeeNameComparator);
   
    Arrays.sort(employeesArrayWithNulls, employeeNameComparator_nullLast);

6)thenComparing
default Comparator<T> thenComparing(Comparator<? super T> other) {
        Objects.requireNonNull(other);
        return (Comparator<T> & Serializable) (c1, c2) -> {
            int res = compare(c1, c2);
            return (res != 0) ? res : other.compare(c1, c2);
        };
    }
Comparator<Employee> employee_Age_Name_Comparator
      = Comparator.comparing(Employee::getAge)
        .thenComparing(Employee::getName);
   
    Arrays.sort(someMoreEmployees, employee_Age_Name_Comparator);


LinkedHashSet
=============
public class LinkedHashSet<E>
    extends HashSet<E>
    implements Set<E>, Cloneable, java.io.Serializable { }

This class extends HashSet, but adds no members of its own.

LinkedHashSet maintains a linked list of the entries in the set, in the order in which they were inserted. This allows insertion-order iteration over the set.

LinkedHashSet internally uses LinkedHashMap to add element to its object .


PriorityQueue 
=============
public class PriorityQueue<E> extends AbstractQueue<E>
    implements java.io.Serializable { }

PriorityQueue is an unbounded Queue implementation in Java, which is based on priority heap.

One of the key thing to remember about PriorityQueue in Java is that it's Iterator doesn't guarantee any order, if you want to traverse in ordered fashion, better use Arrays.sort(pq.toArray()) method. 

PriorityQueue doesn’t permit null.
We can’t create PriorityQueue of Objects that are non-comparable

It inherits methods from AbstractQueue, AbstractCollection, Collection and Object class.

public PriorityQueue(Comparator<? super E> comparator) {
        this(DEFAULT_INITIAL_CAPACITY, comparator);
    }

Priority queue provides O(log(n)) time performance for common enqueing and dequeing methods e.g. offer(), poll() and add(), but constant time for retrieval methods e.g. peek() and element() .
element()- if no element's are there,will throws NSEE

FailFast vs FailSafe
=====================
public class FailFastVsFailSafe {
    
    static void listModification(List<Integer> list) {
        Iterator<Integer> it=list.iterator();
        
        while(it.hasNext())
        {
            Integer x=it.next();
            if(x==7)
            list.remove(x);
        }
    }
    
    
    static void iteratorModification(List<Integer> list) {
        Iterator<Integer> it=list.iterator();
        
        while(it.hasNext())
        {
            int x=it.next();
            if(x==5)
            it.remove();
        }
    }
    
    public static void main(String[] args) {
        
        Stream<Integer> stream=IntStream.range(1,11).boxed();
        Stream<Integer> stream1=IntStream.range(1,11).boxed();
        List<Integer> list=stream.collect(Collectors.toList());
        iteratorModification(list);
        System.out.println(list);
        List<Integer> list1=stream1.collect(Collectors.toList());
        List<Integer> cowal=new CopyOnWriteArrayList<Integer>(list1);
        //cowal internally use COWSubListIterator, where remove method throws UOE
        try {
        iteratorModification(cowal);
        }catch(UnsupportedOperationException uoe) {}
        System.out.println(cowal);
        try {
        listModification(list);
        }catch(ConcurrentModificationException cme) {}
        System.out.println(list);
        
        listModification(cowal);
        System.out.println(cowal);
    }

}

Internallly CopyOnWriteArrayList remove method will modify on snapshot/copy of original array as below code

 public boolean remove(Object o) {
        Object[] snapshot = getArray();
        int index = indexOf(o, snapshot, 0, snapshot.length);
        return (index < 0) ? false : remove(o, snapshot, index);
    }
modCount
--------
    protected transient int modCount

    The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.

    This field is used by the iterator and list iterator implementation returned by the iterator and listIterator methods. If the value of this field changes unexpectedly, the iterator (or list iterator) will throw a ConcurrentModificationException in response to the next, remove, previous, set or add operations. This provides fail-fast behavior, rather than non-deterministic behavior in the face of concurrent modification during iteration.

    Use of this field by subclasses is optional. If a subclass wishes to provide fail-fast iterators (and list iterators), then it merely has to increment this field in its add(int, E) and remove(int) methods (and any other methods that it overrides that result in structural modifications to the list). A single call to add(int, E) or remove(int) must add no more than one to this field, or the iterators (and list iterators) will throw bogus ConcurrentModificationExceptions. If an implementation does not wish to provide fail-fast iterators, this field may be ignored.




